import { EduLogger } from './../logger';
import { LocalUserRenderer, RemoteUserRenderer } from './renderer/index';
import { EventEmitter } from 'events';
import { IMediaService, RTCWrapperProvider, RTCProviderInitParams, CameraOption, MicrophoneOption, PrepareScreenShareParams, StartScreenShareParams } from './interfaces';
import { AgoraElectronRTCWrapper } from './electron';
import { AgoraWebRtcWrapper } from './web';
import AgoraRTC, { ITrack, ILocalTrack } from 'agora-rtc-sdk-ng';

enum ElectronFillMode {
  fillContentMode = 0,
  fitContentMode = 1
}

type JoinOption = {
  channel: string
  token?: string | null
  uid: number
  info?: string
}

/** 
 * This class is used to provide media responsibility.
 * It can support electron & normal web platform.
 * @category MediaService
 */
export class MediaService extends EventEmitter implements IMediaService {
  /**
   * This property provide sdk wrapper instance,
   * It contains web or electron platform api ability.
   * It suppose be only for specified scenario, when the media service dosen't support.
   * @paramType RTCWrapperProvider
   */
  sdkWrapper!: RTCWrapperProvider;


  /**
   * This property provide preview test camera renderer,
   * It generally works with device testing scenario or preview camera device.
   * It generated by @link openTestCamera method
   * @paramType LocalUserRenderer
   */
  cameraTestRenderer?: LocalUserRenderer;

  /**
   * This property provide living camera renderer,
   * It supposed be used in to joined media-service context.
   * It generated by @link openCamera method
   * @paramType LocalUserRenderer
   */
  cameraRenderer?: LocalUserRenderer;

  microphoneTrack?: ILocalTrack;

  /**
   * This property provide living screen share renderer,
   * It supposed be used in to joined media-service context.
   * It generated by screen sharing method
   * @paramType LocalUserRenderer
   */
  screenRenderer?: LocalUserRenderer;

  /**
   * This property provide living remote user renderer.
   * It supposed be used in to joined media-service context.
   * The RemoteUserRenderer provide the web & electron platform render object.
   * You can invoke play method with it to render the remote user video
   * @paramType RemoteUserRenderer
   */
  remoteUsersRenderer: RemoteUserRenderer[] = [];

  /**
   * screen share ids
   * @paramType any[]
   */
  screenShareIds: any[] = []

  /**
   * This is media-service constructor method.
   * 
   * @param rtcProvider {@link RTCProviderInitParams}
   */
  constructor(rtcProvider: RTCProviderInitParams) {
    super();
    EduLogger.info(`[rtcProvider] appId: ${rtcProvider.appId}, platform: ${rtcProvider.platform}`)
    if (rtcProvider.platform === 'electron') {
      const electronLogPath = rtcProvider.electronLogPath as any;
      this.sdkWrapper = new AgoraElectronRTCWrapper({
        logPath: electronLogPath.logPath,
        videoSourceLogPath: electronLogPath.videoSourceLogPath,
        AgoraRtcEngine: rtcProvider.agoraSdk,
        appId: rtcProvider.appId,
      })
      //@ts-ignore
      window.ipc && window.ipc.once("initialize", (events: any, args: any) => {
        const logPath = args[0]
        const videoSourceLogPath = args[2];
        //@ts-ignore
        window.videoSourceLogPath = videoSourceLogPath;
        //@ts-ignore
        window.logPath = logPath
        console.log(`[media-service] set logPath: ${logPath}, ${videoSourceLogPath}`)
        this.electron.setAddonLogPath({logPath, videoSourceLogPath})
        this.electron.enableLogPersist()
      })
    } else {
      this.sdkWrapper = new AgoraWebRtcWrapper({
        uploadLog: true,
        agoraWebSdk: rtcProvider.agoraSdk,
        webConfig: {
          mode: 'live',
          codec: rtcProvider.codec,
          role: 'host',
        },
        appId: rtcProvider.appId
      })
    }
    this.sdkWrapper.on('watch-rtt', (evt: any) => {
      this.fire('watch-rtt', evt)
    })
    this.sdkWrapper.on('network-quality', (quality: any) => {
      // console.log("[media-service] network quality >>>>>>>>>>>", quality)
      this.fire('network-quality', quality)
    })
    this.sdkWrapper.on('connection-state-change', (curState: any) => {
      console.log("[media-service] connection-state-change >>>>>>>>>>>", curState)
      this.fire('connection-state-change', {curState})
    })
    this.sdkWrapper.on('volume-indication', ({totalVolume}: any) => {
      this.fire('volume-indication', {totalVolume})
    })
    this.sdkWrapper.on('exception', (err: any) => {
      this.fire('exception', err)
    })
    this.sdkWrapper.on('user-unpublished', (evt: any) => {
      const user = evt.user
      if (evt.mediaType === 'audio') return
      EduLogger.debug("sdkwrapper user-unpublished", user)
      const userIndex = this.remoteUsersRenderer.findIndex((it: any) => it.uid === user.uid)
      if (userIndex !== -1) {
        const userRenderer = this.remoteUsersRenderer[userIndex]
        this.remoteUsersRenderer.splice(userIndex, 1)
        this.fire('user-unpublished', {
          remoteUserRender: userRenderer
        })
      }
    })
    this.sdkWrapper.on('user-published', (evt: any) => {
      const user = evt.user
      EduLogger.debug("sdkwrapper user-published", user)
      const userIndex = this.remoteUsersRenderer.findIndex((it: any) => it.uid === user.uid)
      if (userIndex === -1) {
        this.remoteUsersRenderer.push(new RemoteUserRenderer({
          context: this,
          uid: +user.uid,
          videoTrack: user.videoTrack,
          sourceType: 'default',
        }))
      } else {
        if (user.videoTrack) {
          this.remoteUsersRenderer[userIndex].videoTrack = user.videoTrack
        }
      }
      this.fire('user-published', {
        remoteUserRender: this.remoteUsersRenderer[userIndex]
      })
    })
    this.sdkWrapper.on('rtcStats', (evt: any) => {
      this.fire('rtcStats', evt)
    })
    this.cameraRenderer = undefined
    this.screenRenderer = undefined
    this.remoteUsersRenderer = []
    AgoraRTC.onCameraChanged = (info: unknown) => {
      this.fire('video-device-changed', (info))
    }
    AgoraRTC.onMicrophoneChanged = (info: unknown) => {
      this.fire('audio-device-changed', (info))
    }
    AgoraRTC.onAudioAutoplayFailed = () => {
      this.fire('audio-autoplay-failed')
    }
  }

  /** @internal */
  private fire(...params: any[]) {
    const [message, ...args] = params
    if (!['volume-indication', 'watch-rtt', 'network-quality'].includes(message)) {
      EduLogger.info(args[0], args)
    }
    this.emit(message, ...args)
  }

  /**
   * get current platform check.
   * check web platform
   * @returns check web platform result @paramType boolean
   */
  get isWeb (): boolean {
    return this.sdkWrapper instanceof AgoraWebRtcWrapper
  }

  /**
   * get current platform check.
   * check electron platform
   * @returns check electron platform result @paramType boolean
   */
  get isElectron (): boolean {
    return this.sdkWrapper instanceof AgoraElectronRTCWrapper
  }

  /**
   * get current used test camera device label
   * @returns label @paramType string
   */
  getTestCameraLabel(): string {
    const defaultLabel = '';
    if (this.isWeb) {
      if (this.web.cameraTestTrack) {
        return this.web.cameraTestTrack.getTrackLabel()
      }
    }
    if (this.isElectron) {
      const deviceId = this.electron.client.getCurrentVideoDevice()
      const videoDeviceList = this.electron.client.getVideoDevices()
      const videoDevice: any = videoDeviceList.find((d: any) => d.deviceid === deviceId)
      if (videoDevice) {
        return videoDevice.devicename
      }
    }
    return defaultLabel
  }


  /**
   * get current used test microphone device label
   * @returns label @paramType string
   */
  getTestMicrophoneLabel(): string {
    const defaultLabel = '';
    if (this.isWeb) {
      if (this.web.microphoneTestTrack) {
        return this.web.microphoneTestTrack.getTrackLabel()
      }
    }
    if (this.isElectron) {
      const deviceId = this.electron.client.getCurrentAudioRecordingDevice()
      const audioDeviceList = this.electron.client.getAudioRecordingDevices()
      const audioDevice: any = audioDeviceList.find((d: any) => d.deviceid === deviceId)
      if (audioDevice) {
        return audioDevice.devicename
      }
    }
    return defaultLabel
  }

  /**
   * get current used camera device label
   * @returns label @paramType string
   */
  getCameraLabel(): string {
    const defaultLabel = '';
    if (this.isWeb) {
      if (this.web.cameraTrack) {
        return this.web.cameraTrack.getTrackLabel()
      }
    }
    if (this.isElectron) {
      const deviceId = this.electron.client.getCurrentVideoDevice()
      const videoDeviceList = this.electron.client.getVideoDevices()
      const videoDevice: any = videoDeviceList.find((d: any) => d.deviceid === deviceId)
      if (videoDevice) {
        return videoDevice.devicename
      }
    }
    return defaultLabel
  }

  /**
   * get current used speaker device label.
   * WARN: It is only work correctly in electron platform.
   * @returns label @paramType string
   */
  getSpeakerLabel(): string {
    if (this.isElectron) {
      const deviceItem = this.electron.client.getPlaybackDeviceInfo()[0]
      return deviceItem.devicename
    }

    return ''
  }


  /**
   * get current used microphone device label
   * @returns label @paramType string
   */
  getMicrophoneLabel(): string {
    const defaultLabel = '';
    if (this.isWeb) {
      if (this.web.microphoneTrack) {
        return this.web.microphoneTrack.getTrackLabel()
      }
    }
    if (this.isElectron) {
      const deviceId = this.electron.client.getCurrentAudioRecordingDevice()
      const audioDeviceList = this.electron.client.getAudioRecordingDevices()
      const audioDevice: any = audioDeviceList.find((d: any) => d.deviceid === deviceId)
      if (audioDevice) {
        return audioDevice.devicename
      }
    }
    return defaultLabel
  }

  /**
   * This is method change the current item's playback volume.
   * In electron platform, it will effect the system volume.
   * In web platform, it only effect the related its own media element's volume.
   * @param volume playback volume value range: (0.0-1.0)
   */
  changePlaybackVolume(volume: number): void {
    if (this.isWeb) {
      this.sdkWrapper.changePlaybackVolume(volume)
    }
    if (this.isElectron) {
      this.sdkWrapper.changePlaybackVolume(volume)
    }
  }
  
  /** @internal */
  async muteLocalVideo(val: boolean): Promise<any> {
    if (this.isWeb) {
      await this.sdkWrapper.muteLocalVideo(val)
    }
    if (this.isElectron) {
      await this.sdkWrapper.muteLocalVideo(val)
    }
  }

  /** @internal */
  async muteLocalAudio(val: boolean): Promise<any> {
    if (this.isWeb) {
      await this.sdkWrapper.muteLocalAudio(val)
    }
    if (this.isElectron) {
      await this.sdkWrapper.muteLocalAudio(val)
    }
  }

  /**
   * This async method is used to mute/unmute specified remote video by passed uid and val
   * @param uid media uid
   * @param val operation: true is mean mute | false is mean unmute
   * @returns Promise<any>
   */
  async muteRemoteVideo(uid: any, val: boolean): Promise<any> {
    if (this.isWeb) {
      await this.sdkWrapper.muteRemoteVideo(uid, val)
    }
    if (this.isElectron) {
      await this.sdkWrapper.muteRemoteVideo(uid, val)
    }
  }

  /**
   * This async method is used to mute/unmute specified remote audio by passed uid and val
   * @param uid media uid
   * @param val operation: true is mean mute | false is mean unmute
   * @returns Promise<any>
   */
  async muteRemoteAudio(uid: any, val: boolean): Promise<any> {
    if (this.isWeb) {
      await this.sdkWrapper.muteRemoteAudio(uid, val)
    }
    if (this.isElectron) {
      await this.sdkWrapper.muteRemoteAudio(uid, val)
    }
  }

  /**
   * This async method is used to mute/unmute specified client and remote video by passed uid and val
   * This method is only provided for web platform.
   * @param client which client will be used
   * @param uid media uid
   * @param val operation: true is mean mute | false is mean unmute
   * @returns Promise<any>
   */
  async muteRemoteVideoByClient(client: any, uid: any, val: boolean): Promise<any> {
    if (this.isWeb) {
      await this.sdkWrapper.muteRemoteVideoByClient(client, uid, val)
    } else {
      throw 'electron not implemented'
    }
  }

  /**
   * This async method is used to mute/unmute specified client and remote audio by passed uid and val
   * This method is only provided for web platform.
   * @param client which client will be used
   * @param uid media uid
   * @param val operation: true is mean mute | false is mean unmute
   * @returns Promise<any>
   */
  async muteRemoteAudioByClient(client: any, uid: any, val: boolean): Promise<any> {
    if (this.isWeb) {
      await this.sdkWrapper.muteRemoteAudioByClient(client, uid, val)
    } else {
      throw 'electron not implemented'
    }
  }

  /**
   * @returns web platform rtc wrapper @link AgoraWebRtcWrapper
   */
  get web (): AgoraWebRtcWrapper {
    return (this.sdkWrapper as AgoraWebRtcWrapper)
  }

  /**
   * @returns electron platform rtc wrapper @link AgoraElectronRTCWrapper
   */
  get electron (): AgoraElectronRTCWrapper {
    return (this.sdkWrapper as AgoraElectronRTCWrapper)
  }

  /**
   * This method is init the media-service lifecycle
   */
  init() {
    if (this.isWeb) {
      this.sdkWrapper.init()
    }

    if (this.isElectron) {
      this.sdkWrapper.init()
    }
  }

  /**
   * This method is release the media-service lifecycle
   */
  release () {
    if (this.isWeb) {
      this.sdkWrapper.release()
    }

    if (this.isElectron) {
      this.sdkWrapper.release()
    }
  }

  /**
   * This method is used to join media channel
   * so that you can interactive your media ability with other participants in the same channel
   * @params option @paramType JoinOption
   * @returns join result @paramType Promise<any>
   */
  async join(option: JoinOption): Promise<any> {
    if (this.isWeb) {
      await this.sdkWrapper.join(option)
    }
    if (this.isElectron) {
      await this.sdkWrapper.join(option)
    }
  }

  /**
   * This method is used to leave media channel
   * so that you can stop interactive your media ability with other participants in the same channel
   * @returns leave result @paramType Promise<any>
   */
  async leave(): Promise<any> {
    if (this.isWeb) {
      await this.sdkWrapper.leave()
    }
    if (this.isElectron) {
      await this.sdkWrapper.leave()
    }
  }

  /**
   * This method is used to join sub channel media channel
   * so that you can start interactive your media ability with other participants in the same channel
   * @param option @paramType JoinOption
   * @returns join result @paramType Promise<any>
   */
  async joinChannel(option: JoinOption): Promise<any> {
    if (this.isWeb) {
      await this.sdkWrapper.joinChannel(option)
    } else {
      throw 'electron no implement'
    }
  }

  /**
   * This method is used to leave sub channel media channel
   * so that you can stop interactive your media ability with other participants in the same channel
   * @param option @paramType JoinOption
   * @returns leave result @paramType Promise<any>
   */
  async leaveChannel(option: JoinOption): Promise<any> {
    if (this.isWeb) {
      await this.sdkWrapper.leaveChannel(option)
    } else {
      throw 'electron no implement'
    }
  }

  // async publishChannel(): Promise<any> {
  //   if (this.isWeb) {
  //     await this.sdkWrapper.publishChannel()
  //   } else {
  //     throw 'electron no implement'
  //   }
  // }

  // async unpublishChannel(): Promise<any> {
  //   if (this.isWeb) {
  //     await this.sdkWrapper.unpublishChannel()
  //   } else {
  //     throw 'electron no implement'
  //   }
  // }

  /**
   * This method is used to publish media in the joined channel
   * so that you can start interactive your media ability with other participants in the same channel
   * @returns publish result @paramType Promise<any>
   */
  async publish(): Promise<any> {
    if (this.isWeb) {
      await this.sdkWrapper.publish()
    }
    if (this.isElectron) {
      await this.sdkWrapper.publish()
    }
  }

  /**
   * This method is used to unpublish media in the joined channel
   * so that you can stop interactive your media ability with other participants in the same channel
   * @returns unpublish result @paramType Promise<any>
   */
  async unpublish(): Promise<any> {
    if (this.isWeb) {
      await this.sdkWrapper.unpublish()
    }
    if (this.isElectron) {
      await this.sdkWrapper.unpublish()
    }
  }

  /**
   * This method is used to openCamera in the joined channel
   * so that you can start interactive your camera ability with other participants in the same channel
   * @param option @paramType CameraOption
   * @returns openCamera result @paramType Promise<any>
   */
  async openCamera(option?: CameraOption): Promise<any> {
    if (this.isWeb) {
      await this.sdkWrapper.openCamera(option)
      if (!this.web.cameraTrack) return

      if (!this.cameraRenderer) {
        this.cameraRenderer = new LocalUserRenderer({
          context: this,
          uid: 0,
          sourceType: 'default',
          videoTrack: this.web.cameraTrack
        })
      } else {
        this.cameraRenderer.videoTrack = this.web.cameraTrack
      }
    }
    if (this.isElectron) {
      await this.sdkWrapper.openCamera()

      if (!this.cameraRenderer) {
        this.cameraRenderer = new LocalUserRenderer({
          context: this,
          uid: 0,
          sourceType: 'default',
        })
      }
    }
  }

  /**
   * This method is used to changeCamera in the joined channel
   * so that you can interactive switch another camera ability with other participants in the same channel
   * @param deviceId @paramType string
   * @returns changeCamera result @paramType Promise<any>
   */
  async changeCamera(deviceId: string): Promise<any> {
    if (this.isWeb) {
      await this.sdkWrapper.changeCamera(deviceId)
    }
    if (this.isElectron) {
      await this.sdkWrapper.changeCamera(deviceId)
    }
  }

  /**
   * This method is used to close in the joined channel
   * so that you can stop interactive your camera ability with other participants in the same channel
   * @returns closeCamera result @paramType Promise<any>
   */
  async closeCamera() {
    if (this.isWeb) {
      await this.sdkWrapper.closeCamera()
    }
    if (this.isElectron) {
      await this.sdkWrapper.closeCamera()
    }
    if (this.cameraRenderer) {
      this.cameraRenderer.stop()
      this.cameraRenderer = undefined
    }
  }

  /**
   * This method is used to openMicrophone in the joined channel
   * so that you can start interactive your microphone ability with other participants in the same channel
   * @param option @paramType MicrophoneOption
   * @returns openMicrophone result @paramType Promise<any>
   */
  async openMicrophone(option?: MicrophoneOption): Promise<any> {
    if (this.isWeb) {
      await this.sdkWrapper.openMicrophone(option)
      this.microphoneTrack = this.web.microphoneTrack
    }
    if (this.isElectron) {
      await this.sdkWrapper.openMicrophone(option)
      //@ts-ignore
      this.microphoneTrack = {}
    }
  }

  /**
   * This method is used to changeMicrophone in the joined channel
   * so that you can interactive switch another microphone ability with other participants in the same channel
   * @param deviceId @paramType string
   * @returns changeMicrophone result @paramType Promise<any>
   */
  async changeMicrophone(deviceId: string): Promise<any> {
    if (this.isWeb) {
      await this.sdkWrapper.changeMicrophone(deviceId)
    }
    if (this.isElectron) {
      await this.sdkWrapper.changeMicrophone(deviceId)
    }
  }

  /**
   * This method is used to close in the joined channel
   * so that you can stop interactive your microphone ability with other participants in the same channel
   * @returns closeMicrophone result @paramType Promise<any>
   */
  async closeMicrophone() {
    await this.sdkWrapper.closeMicrophone()
    this.microphoneTrack = undefined
  }


  /**
   * This method is used to open test camera
   * @param option @paramType CameraOption
   * @returns result @paramType Promise<any>
   */
  async openTestCamera(option: CameraOption): Promise<any> {
    if (this.isWeb) {
      await this.sdkWrapper.openTestCamera(option)
      if (!this.web.cameraTestTrack) return

      if (!this.cameraTestRenderer) {
        this.cameraTestRenderer = new LocalUserRenderer({
          context: this,
          uid: 0,
          sourceType: 'default',
          videoTrack: this.web.cameraTestTrack
        })
      } else {
        this.cameraTestRenderer.videoTrack = this.web.cameraTestTrack
      }
    }
    if (this.isElectron) {
      await this.sdkWrapper.openTestCamera()

      if (!this.cameraTestRenderer) {
        this.cameraTestRenderer = new LocalUserRenderer({
          context: this,
          uid: 0,
          sourceType: 'default',
        })
      }
    }
  }

  /**
   * This method is used to close test camera
   * @returns undefined @paramType void
   */
  closeTestCamera() {
    this.sdkWrapper.closeTestCamera()
    if (this.cameraTestRenderer) {
      this.cameraTestRenderer.stop()
      this.cameraTestRenderer = undefined
    }
  }


  /**
   * This method is used to change test camera device
   * @param deviceId @paramType string
   * @returns result @paramType Promise<any>
   */
  async changeTestCamera(deviceId: string): Promise<any> {
    if (this.isWeb) {
      await this.sdkWrapper.changeTestCamera(deviceId)
    }
    if (this.isElectron) {
      await this.sdkWrapper.changeTestCamera(deviceId)
    }
  }

  /**
   * This method is used to change test camera
   * @param config @paramType MicrophoneOption
   * @returns result @paramType Promise<any>
   */
  async changeTestResolution(config: any) {
    if (this.isWeb) {
      await this.web.changeTestResolution(config)
    }
    if (this.isElectron) {
      await this.electron.changeTestResolution(config)
    }
  }

  /**
   * This method is used to open test microphone
   * @param option @paramType MicrophoneOption
   * @returns result @paramType Promise<any>
   */
  async openTestMicrophone(option?: MicrophoneOption): Promise<any> {
    await this.sdkWrapper.openTestMicrophone(option)
  }

  /**
   * This method is used to close test microphone
   * @returns undefined @paramType void
   */
  closeTestMicrophone() {
    this.sdkWrapper.closeTestMicrophone()
  }

  /**
   * This method is used to change test microphone device
   * @param id @paramType string
   * @returns result @paramType Promise<any>
   */
  async changeTestMicrophone(id: string): Promise<any> {
    await this.sdkWrapper.changeTestMicrophone(id)
  }

  /**
   * This method get the platform related cameras list.
   * @returns cameras list @paramType Promise<any[]>
   */
  async getCameras(): Promise<any> {
    if (this.isWeb) {
      return await this.web.getCameras()
    }

    if (this.isElectron) {
      return await this.electron.getCameras()
    }
  }

  /**
   * This method get the platform related microphones list.
   * @returns microphones list @paramType Promise<any[]>
   */
  async getMicrophones(): Promise<any> {
    if (this.isWeb) {
      return await this.web.getMicrophones()
    }

    if (this.isElectron) {
      return await this.electron.getMicrophones()
    }
  }

  /**
   * This method is used to prepare screen sharing for permission checking.
   * In macos catalina system, start screen sharing need grant permission.
   * @param params @paramType PrepareScreenShareParams
   * @returns prepare result @paramType Promise<any>
   */
  async prepareScreenShare(params: PrepareScreenShareParams = {}): Promise<any> {
    if (this.isWeb) {
      await this.sdkWrapper.prepareScreenShare(params)
      this.screenRenderer = new LocalUserRenderer({
        context: this,
        uid: 0,
        videoTrack: this.web.screenVideoTrack as ITrack,
        sourceType: 'screen',
      })
    }
    if (this.isElectron) {
      let items = await this.sdkWrapper.prepareScreenShare()
      return items
    }
  }

  /**
   * This method is used to start screen sharing.
   * It will interactive with same channel's participants.
   * @param option @paramType StartScreenShareParams
   * @returns start result @paramType Promise<any>
   */
  async startScreenShare(option: StartScreenShareParams): Promise<any> {
    if (this.isWeb) {
      await this.sdkWrapper.startScreenShare(option)
    }
    if (this.isElectron) {
      await this.sdkWrapper.startScreenShare(option)
      this.screenRenderer = new LocalUserRenderer({
        context: this,
        uid: 0,
        videoTrack: undefined,
        sourceType: 'screen',
      })
    }
  }

  /**
   * This method is used to stop screen sharing
   * @returns stop result @paramType Promise<any>
   */
  async stopScreenShare(): Promise<any> {
    if (this.isWeb) {
      await this.sdkWrapper.stopScreenShare()
    }
    if (this.isElectron) {
      await this.sdkWrapper.stopScreenShare()
    }
  }

  /**
   * This method is only work for change camera device resolution.
   * It will effect the published camera sender resolution.
   * @param config resolution config
   * @returns changeResolution result @paramType Promise<any>
   */
  async changeResolution(config: any) {
    if (this.isWeb) {
      await this.web.changeResolution(config)
    }
    if (this.isElectron) {
      await this.electron.changeResolution(config)
    }
  }

  /**
   * This method is supposed be used in electron platform
   */
  getPlaybackVolume(): number {
    if (this.isElectron) {
      return +(this.electron.client.getAudioPlaybackVolume() / 255 * 100).toFixed(1) 
    }
    return 100;
  }

  /**
   * reset media-service state
   */
  reset(): void {
    if (this.isWeb) {
      this.web.reset()
    }
    if (this.isElectron) {
      this.electron.reset()
    }
  }
}